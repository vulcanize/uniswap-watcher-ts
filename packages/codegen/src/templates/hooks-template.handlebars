//
// Copyright 2021 Vulcanize, Inc.
//

import assert from 'assert';
import * as codec from '@ipld/dag-json';
import { sha256 } from 'multiformats/hashes/sha2';
import { CID } from 'multiformats/cid';
import _ from 'lodash';

import { BlockProgressInterface } from '@vulcanize/util';

import { Indexer, ResultEvent } from './indexer';
import { IPLDBlock } from './entity/IPLDBlock';

export async function handleBlock (indexer: Indexer, jobData: any): Promise<void> {
  // Get events for current block and make an entry of updated values in IPLDBlock.

  const { blockHash } = jobData;
  const events = await indexer.getEventsByFilter(blockHash);

  // No IPLDBlock entry if there are no events.
  if (!events) return;

  for (const event of events) {
    const block = event.block;
    const contractAddress = event.contract;

    const ipldBlockData: any = {};

    // Get an existing IPLDBlock for current block and contractAddress.
    const oldIpldBlock = await indexer.getIPLDBlock(block, contractAddress);

    if (!oldIpldBlock) {
      ipldBlockData.meta = {
        id: contractAddress,
        kind: 'diff',
        parent: {
          '/': (await indexer.getPrevIPLDBlock(blockHash, contractAddress))?.cid || null
        },
        ethBlock: {
          cid: {
            '/': block.cid
          },
          num: block.blockNumber
        }
      };
    }

    const eventData = indexer.getResultEvent(event);

    switch (event.eventName) {
      case 'Transfer': {
        const { from, to } = eventData.event;

        const fromBalance = await indexer._balances(blockHash, contractAddress, from);
        const toBalance = await indexer._balances(blockHash, contractAddress, to);

        // {
        //   "_balances": {
        //      "0xCA6D29232D1435D8198E3E5302495417dD073d61": {
        //         "value": 100
        //      },
        //      "0xDC7d7A8920C8Eecc098da5B7522a5F31509b5Bfc": {
        //         "value": 999999999999999999900
        //      }
        //   }
        // }
        _.set(ipldBlockData, `state._balances[${from}]`, fromBalance.value.toString());
        _.set(ipldBlockData, `state._balances[${to}]`, toBalance.value.toString());

        break;
      }

      case 'Approval': {
        const { owner, spender } = eventData.event;
        const allowance = await indexer._allowances(blockHash, contractAddress, owner, spender);

        // {
        //   "_allowances": {
        //      "0xDC7d7A8920C8Eecc098da5B7522a5F31509b5Bfc": {
        //         "0xCA6D29232D1435D8198E3E5302495417dD073d61": {
        //            "value": 10
        //         }
        //      }
        //   }
        // }
        _.set(ipldBlockData, `state._allowances[${owner}][${spender}]`, allowance.value.toString());

        break;
      }
    }

    const ipldBlock = await prepareIPLDBlock(block, contractAddress, ipldBlockData, oldIpldBlock);
    await indexer.saveOrUpdateIPLDBlock(ipldBlock);
  }
}

async function prepareIPLDBlock (block: BlockProgressInterface, contractAddress: string, data: any, oldIpldBlock?: IPLDBlock):Promise<any> {
  // If an IPLDBlock for { block, contractAddress } already exists, update the data field.
  if (oldIpldBlock) {
    const oldData = codec.decode(Buffer.from(oldIpldBlock.data));
    data = _.merge(oldData, data);
  }

  // Encoding the data using dag-json codec.
  const bytes = codec.encode(data);

  // Calculating sha256 (multi)hash of the encoded data.
  const hash = await sha256.digest(bytes);

  // Calculating the CID: v1, code: dag-json, hash.
  const cid = CID.create(1, codec.code, hash);

  let ipldBlock = oldIpldBlock || new IPLDBlock();
  ipldBlock = Object.assign(ipldBlock, {
    block,
    contractAddress,
    cid: cid.toString(),
    data: bytes
  });

  return ipldBlock;
}

/**
 * Event hook function.
 * @param indexer Indexer instance that contains methods to fetch and update the contract values in the database.
 * @param eventData ResultEvent object containing necessary information.
 */
export async function handleEvent (indexer: Indexer, eventData: ResultEvent): Promise<void> {
  assert(indexer);
  assert(eventData);

  // The following code is for ERC20 contract implementation.

  // Perform indexing based on the type of event.
  switch (eventData.event.__typename) {
    // In case of ERC20 'Transfer' event.
    case 'TransferEvent': {
      // On a transfer, balances for both parties change.
      // Therefore, trigger indexing for both sender and receiver.

      // Get event fields from eventData.
      // const { from, to } = eventData.event;

      // Update balance entry for sender in the database.
      // await indexer.balanceOf(eventData.block.hash, eventData.contract, from);

      // Update balance entry for receiver in the database.
      // await indexer.balanceOf(eventData.block.hash, eventData.contract, to);

      break;
    }
    // In case of ERC20 'Approval' event.
    case 'ApprovalEvent': {
      // On an approval, allowance for (owner, spender) combination changes.

      // Get event fields from eventData.
      // const { owner, spender } = eventData.event;

      // Update allowance entry for (owner, spender) combination in the database.
      // await indexer.allowance(eventData.block.hash, eventData.contract, owner, spender);

      break;
    }
  }
}
